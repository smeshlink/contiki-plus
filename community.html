---
layout: default
title: Contiki 社区
community: true
permalink: /community/
---

		<div class="container">
			<header class="page-header">
				<h1>{{ page.title }}</h1>
			</header>
			<div class="row">
				<div class="span3">
					<h2>邮件列表</h2>
					<p>Contiki 是由来自世界各地的众多开发者组成的社区共同开发，许多个体对 Contiki 的发展做出了贡献。社区的核心是 <code>contiki-developers</code> 邮件列表。</p>
					<p><a href="https://lists.sourceforge.net/lists/listinfo/contiki-developers">加入 contiki-developers 邮件列表 »</a></p>
					<p><a href="http://sourceforge.net/mailarchive/forum.php?forum_name=contiki-developers">存档 »</a></p>
				</div>
				<div class="span3">
					<h2>交流论坛</h2>
					<p><a href="http://www.contikistudio.com">Contiki Studio »</a></p>
					<p><a href="http://www.iotdev.net">IOTDEV.NET »</a></p>
				</div>
				<div class="span3">
					<h2>开发进展</h2>
					<p>Contiki 开发使用了 <a href="http://en.wikipedia.org/wiki/Git_(software)">Git</a> 进行版本控制。Contiki 代码仓库位于 GitHub ：</p>
					<p><a href="https://github.com/contiki-os/contiki">contiki-os/contiki »</a></p>
					<p><a href="https://github.com/smeshlink/contiki-plus">smeshlink/contiki-plus »</a></p>
				</div>
				<div class="span3">
					<h2>贡献源码</h2>
					<p>Contiki 采用 GitHub Pull Request 机制处理个人或组织的代码贡献，详情请点击<a href="https://github.com/contiki-os/contiki/wiki/Pull-Request-Policy">这里</a>查看。</p>
				</div>
			</div>
			<section>
				<header class="page-header">
					<h1>Contiki 发展</h1>
				</header>
				<div class="row">
					<div class="span4">
						<h2>Contiki 历史</h2>
						<p>Contiki 起源于 <a href="http://dunkels.com/adam/">Adam Dunkels</a> 的奇思妙想：将一些莫名其妙的东西连入互联网。2001年，<a href="http://en.wikipedia.org/wiki/LwIP">lwIP</a>的胞弟，开源项目<a href="http://en.wikipedia.org/wiki/UIP_(micro_IP)">uIP</a>协议栈发布了，很快在嵌入式领域流行开来。但uIP并不仅仅被用在众多底层嵌入式系统中，它能够接入互联网，因此可以做到一些<a href="http://slashdot.org/story/02/01/29/2115210/tcpip-enabled-lego-brick">意想不到的事情</a>。2003年， <a href="http://news.slashdot.org/story/03/03/10/1211249/the-contiki-desktop-os-for-c64-nes-8-bit-atari">Contiki</a> <a href="http://tech.slashdot.org/story/03/07/03/130206/contiki-on-ethernut">问世</a>了。</p>
						<p>2004年，Contiki <a href="http://sourceforge.net/mailarchive/message.php?msg_id=6338440">引入</a>了 <a href="http://en.wikipedia.org/wiki/Protothreads">protothreads</a> 的概念，这个概念组成了 Contiki 进程的基础。在2007年， Contiki 加入了 Cooja 和 Rime 栈的早期版本，并实现了功耗分析。2008年初引入 Instant Contiki 和 Coffee 文件系统，同年晚些时候， Cisco 为 Contiki <a href="http://investor.cisco.com/releasedetail.cfm?releaseid=340400">贡献</a>了经过完整认证的IPv6栈。</p>
						<p>在2009与2010年， Contiki 增加了对许多新的硬件平台的支持，并开发了一套新的低功耗机制。2011年则引入了两个重要机制：实现IPv6路由的 ContikiRPL ，和实现休眠路由的 ContikiMAC 。</p>
						<p>2012年， <a href="http://thingsquare.com/">Thingsquare</a> 成立，将 Contiki 带入了云计算。</p>
					</div>
					<div class="span8">
						<h2>Contiki 开发者</h2>
						<p>Contiki 是由一大波开发者共同开发，在这里罗列出来以铭记他们和他们的贡献（以某种半随机顺序）。由于贡献者太多，这里非常可能不小心遗漏了谁，如果你发现自己属于这种情况，请<a href="{{ site.url }}/contact/">联系我们</a>！</p>
						<p>Adam Dunkels 开发了 Contiki 的基础与大部分核心功能，如内核、多数库、uIP栈和Rime栈等。 Giovanni Pellerano 进行了pic32的移植。 Oliver Schmidt 将 Contiki 移植到了 Microsoft Windows 和 Apple II ，并参与了 protothreads 的开发。 Niclas Finne 负责Z1和Wismot的移植，还开发了一部分 MSPsim 模拟器。 Joakim Eriksson 编写了 MSPsim 和 ContikiRPL 。 Fredrik Österlind 编写了网络模拟器 Cooja 和回归测试框架。 Nicolas Tsiftes 开发了 Coffee 文件系统、 ContikiRPL 和 Antelope 数据库。 Julien Abeillé 和 Mathilde Durvy 共同编写了 IPv6 栈和 6lowpan 适配层。 Mariano Alvira 移植了 econotag 。 David Kopf 在 Raven 移植上做了许多工作。 Matthias Kovatsch 为 Contiki 编写了 CoAP 客户端与服务端库 Erbium 。 Simon Duquennoy 在流传输方面对 ContikiMAC 进行了优化。 Simon Barner 最先进行 AVR 移植， Simon Berg 做了 AT91SAM7s 的移植， Colin O'Flynn 实现了 AVR Raven 的移植和具有 IPv6 网络桥接功能的 USB stick 。 Eric Gnoske ， Michael Vidales ，和 Blake Leverett 也进行了 AVR Raven 的移植， Ivan Delamer 则参与了AVR移植。 Anthony Asterisk 移植了 8051 。 Zach Shelby 进行了 Sensinode 移植的初始工作， George Oikonomou 则开发了 CC2530 的移植。Salvatore Pitrulli 移植了 STM32w 。
						Dogan Yazar 为 Contiki 开发了一个 REST 风格的 HTTP/CoAP 层。 Enric M. Calvo 和 Antonio Lignan 实现了 Z1 的移植。 Björn Grönvall 实现了最初的 Tmote Sky 移植。 Kasun 移植了 MiacZ 。 Matthias Bergvall 编写了 CTK-over-Telnet GUI界面。 Groepaz 实现了 NES 和  PCEngine 的初步移植。 Takahide Matsutsuka 移植了 PC-6001 。 Lawrence Chitty 移植了 Sharp Wizard 。 Fabio Fumi 将 Contiki 移植到了 Casio PocketViewer 。 Matthias Domin 移植了 Atari Jaguar 。 Christian Groessler 移植了 Atari 8位机。 Anders Carlsson 移植了 VIC-20 。 James Dessart 把 Contiki 移植到了 CoCo Color 计算机。 Chris Morse 完成 Apple II 移植的初始工作。 Mikael Backlund 设计了 Contiki 早期版本的图标。</p>
					</div>
				</div>
			</section>
			<section>
				<header class="page-header">
					<h1>Contiki 代码样式</h1>
					<p>贡献到 Contiki 的代码都必须遵循 Contiki 代码样式</p>
				</header>
				<div class="row">
					<div class="span3">
						<h3>代码样式自动格式化</h3>
						<p>Contiki 源码树中包含一个 GNU Indent 文件，用于自动将C源文件格式化为 Contiki 源码格式，该文件位于 <code>contiki/tools/contiki-indent</code> 。 GNU Indent 规范请参考 <code>contiki/tools/indent.pro</code> 。</p>
					</div>
					<div class="span9">
						<h2>Contiki 代码样式</h2>
						<p>Contiki 代码样式示例文件位于 <code>contiki/docs/code-style.c</code> 。</p>
						{% highlight c %}
/**
 * \defgroup coding-style Coding style
 *
 * Doxygen 模块的文档是以 Doxygen 关键词 \defgroup 作为文件开头，
 * 表示定义一个模块，在其他属于这一个模块的所有文件中，使用
 * Doxygen 关键词 \addtogroup 。
 * 通常， \defgroup 放在 .h 文件中， \addtogroup 放在相应的 .c 文件中。
 *
 * @{
 */

/**
 * \file
 *         文件的简要描述
 * \author
 *         Adam Dunkels <adam@dunkels.com>
 * 
 *         文档模块每一部分文件都需要有一个 \file 块， 否则这个
 *         文件将不会出现在 Doxygen "Modules" 区域。
 */

/* 这是单行注释。 */

/*
 * 这是多行注释。注释最好是完整的语句，看起来像真实段落。
 */

#include "contiki.h"

/*
 * 确保所有的非全局变量都定义有 static 关键字。
 * 这样有助于减小符号表。
 */
static int flag;

/*
 * 外部文件可见的所有全局变量与全局函数的名称需要以模块名称为开头，
 * 这样查找函数与变量定义的时候会更加方便。
 *
 * 在函数之间使用如下的分隔符（由下划线组成的单行注释）。
 */
/*---------------------------------------------------------------------------*/
/**
 * \brief      Use Doxygen documentation for functions.
 * \param c    简要描述所有的参数。
 * \return     简要描述返回值。
 * \retval 0   对于返回特定值的函数，
 * \retval 1   可以使用 \retval 关键词替代 \return 。
 *
 *             把函数功能的完整描述放在 Doxygen 关键词的后面。
 *
 *             使用这个模板来书写函数文档。
 *             在说明之后的文本都是用于函数文档。
 *
 *             函数原型的返回值单独放在一行，
 *             函数名和参数另起一行，
 *             函数名与首括号间不需要空格，
 *             左大括号单独另起一行。
 */
void
code_style_example_function(void)
{
  /*
   * 总是在函数开始定义局部变量。
   */
  int i;                   /* 对于循环计数变量，使用简短的名字 */

  /*
   * 关键字和第一个括号之间不要有空格，
   * 二元运算符两边需要有空格，
   * 一元运算符和运算数之间不用空格。
   *
   * for(), if(), do, 和 case() 语句的大括号与语句放在同一行
   */
  for(i = 0; i < 10; ++i) {
    /*
     * 不要省略 if(), for(), 和 while() 语句的大括号，
     * 即使它们内部只有单行语句。
     * 这样可以增强代码的可读性，减少修改代码时引入错误的可能性。
     */
    if(i == c) {
      return c;           /* 返回值不需要括号()。 */
    } else {              /* else 关键字与左右的大括号同放在
			     单独的一行。 */
      c++;
    }
  }
}
/*---------------------------------------------------------------------------*/
/*
 * static （非全局）函数不需要 Doxygen 注释。
 * 为了避免混淆，函数名称也不要以模块名称开头。
 */
static void
an_example_function(void)
{
  
}
/*---------------------------------------------------------------------------*/

/* 最后的符号用于结束文件开头的 \defgroup 块： */

/** @} */{% endhighlight %}
					</div>
				</div>
			</section>
		</div>